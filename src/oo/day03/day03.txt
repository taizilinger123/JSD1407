回顾：
1.方法签名：方法名+参数列表
2.方法的重载：(overload):
                同一个类中，方法名称相同，参数列表不同
                编译器在编译时会自动根据签名来绑定调用不同的方法
3.构造方法：
                给成员变量初始化
                与类同名，没有返回类型
                创建对象时被自动调用
                不写则默认无参构造，自己写了则不再默认提供
                可以重载
4.this:指代当前对象，哪个对象调用指的就是哪个对象
                     方法中访问成员变量之前默认有个this.
       this.成员变量名
       this.方法名()
       this()       
5.引用类型数组：
   Cell[] cells = new Cell[4];//创建Cell数组对象
   cells[0] = new Cell(2,5);//创建Cell对象
   
   int[][] arr = new int[3][];
   arr[0] = new int[2];


Cell c = new Cell();
c.row = 2;
c.col = 5;
c.drop();

Cell cc = new Cell();
cc.drop();

class Cell{
    int row;
    int col;
    Cell(int row,int col){
       this.row=row;
       this.col=col;
    }
    void  drop(){
      this.row++;
    }
}

class O{
   Cell[] cells;
   O(int row,int col){
      cells = new Cell[4];
      cells[0] = new Cell(row, col);
      cells[1] = new Cell(row, col+1);
      cells[2] = new Cell(row+1, col);
      cells[3] = new Cell(row+1, col+1);
   }
   void drop(){}
   void moveLeft(){}
   void moveRight(){}
   void print(){}
}
正课：
1.内存管理：由JVM来管理
   1）堆：
     1.1)用于存储所有new出来的对象(包括成员变量)
     1.2)成员变量的生命周期：
                               创建(new)对象时存在堆中，对象被GC回收时一并消失
     1.3)垃圾：没有任何引用所指向的对象
                           垃圾回收器(GC)不定时到堆中查看，看到垃圾则自动回收
                           回收过程是透明的，并不是一看到垃圾就马上回收
                           若想让它快一些收，可以调用System.gc()                 
     1.4)内存泄露：不再使用的对象没有被及时的回收
                                                建议：当对象不再使用时应及时将引用设置为null
   2）栈：
     2.1)用于存储正在调用中的方法的所有局部变量(包括参数)
     2.2)调用方法时在栈中为该方法分配一块对应的栈桢
                           栈桢中包含所有的局部变量(包括参数)，
                           方法调用结束时，栈桢消失，局部变量一并消失
     2.3)局部变量的生命周期：
                               调用方法时存在栈中，方法调用结束时与栈桢一并消失
   3）方法区：
     3.1)用于存储.class字节码文件(包括方法)
     3.2)方法只有一份
2.继承：
3.super：
4.向上造型：

每个对象有自己独立的row和col
所有对象共享一个drop()方法
class Cell{
   int row;
   int col;
   void drop(){
     row++;
   }
}


class Aoo{
 int a;
 void show(){
	 int b;
	 System.out.println(a);
	 System.out.println(b);//编译错误
 }
}
Aoo o = new Aoo();
成员变量：
1.类中，方法外
2.new时存在堆中，对象被回收时消失
3.有默认值
局部变量：
1.方法中
2.调方法时存在栈中，方法调用结束时与栈桢一并消失
3.没有默认值



自动垃圾回收机制------------GC垃圾回收器
C++：自己回收垃圾

java程序，运行运行，报内存不足
中关村买了一个2G内存条，装到我的电脑上

运行------------依然是内存不足
如何解决？--------给JVM扩大内存
