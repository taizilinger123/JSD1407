回顾：
1.内存管理：堆、栈、方法区
2.继承：避免代码重复，有利于代码的重用
      extends
                  父：共有的  子：特有的
                  子继承父，子具有：父+子
                  单一继承，传递性
                  构造子之前必须先构造父，子构造中若不写，则默认super()调父类的无参构造，若自己写了，则不再默认提供
3.super：指代当前对象的父类对象
      super.成员变量名
      super.方法名()
      super()
4.向上造型：
  1)父类型的引用指向子类的对象
  2)能点出来什么，看引用的类型


正课：
1.方法的重写(Override):
  1)发生在父子类中，方法名相同，参数列表相同，方法体不同
  2)重写方法被调用时，看对象的类型
2.重写与重载的区别：----常见面试题
  1)重写:父子类中，方法名相同，参数列表相同，方法体不同
                      遵循"运行期"绑定，根据对象的类型调用方法
  2)重载:一个类中，方法名相同，参数列表不同，方法体不同
                      遵循"编译期"绑定，根据引用的类型绑定方法
3.package：
  1)作用：避免类的命名冲突
  2)包名可以有层次结构
  3)建议：包名所有字母都小写
  4)类的完全限定名：包名.类型
  import:
  1)作用:声明类/引入类
  2)同包中的类可以直接访问
            不同包中的类想访问：
      2.1)先import声明类再访问类(建议)
      2.2)类的全称-----太繁琐(不建议)
4.访问控制修饰符：
  1)public:公开的，任何类
  2)private:私有的，本类
  3)protected:受保护的，本类、子类、同包类
  4)默认的：什么也不写，本类、同包类
      类的访问修饰：public和默认的(默认的就是什么都不写)
      类成员的访问修饰：如上4种都可以
5.static:
6.final:


数据私有化(private)，行为公开化(public)
class Card{
  private  String cardId; //卡号
  private  String cardPwd;//密码
  private  double balance;//余额
  
  public boolean payMoney(double money){//支付金额
    if(balance>=money){
       balance-=money;
       return true;
    }
    return false;
  }
  
  public boolean checkPwd(string pwd){//检查密码
    if(cardPwd.equals(pwd)){
       return true;
    } 
    return false;
  }
}

package a.b.c.d.e.f;
class Aoo{
}
class Boo{
  void show(){
     Aoo o = new Aoo();
  }
}

package b;
import a.b.c.d.e.f.Aoo;
class Coo{
  void show(){
     Aoo o = new Aoo();
  }
}

java项目比较大

项目非常大的时候，建议：
域名反写.项目名称.模块名称.类型
cn.tedu . manager . stumanager . Student

类型从小到大依次为：
byte,short,int,long,float,double
     char


我继承了一个饭店(中餐)
----我还是中餐(不需要重写)
----我改为西餐(重写)
----我想中餐之上加个西餐(重写并super)

Student zs = new Student();
zs.name = "zhangsan";
zs.age = 25;
zs.address = "廊坊";
zs.className = "JSD1604";
zs.sayHi();//zhangsan, 25,廊坊,JSD1604

Teacher wkj = new Teacher();
wkj.name = "wangkejing";
wkj.age = 37;
wkj.address = "佳木斯";
wkj.salary = 5000;
wkj.sayHi();//wangkejing,37,佳木斯

Doctor doc = new Doctor();
doc.name = "lisi";
doc.age = 45;
doc.address = "山东";
doc.level = "主任医师";
doc.sayHi();//lisi,45,山东

能点出来什么，看引用的类型(看前面p1/p2前面),向上造型，前后不一样，父造子,调用子类的
重写方法被调用时，看对象的类型(看new后面)
Student  p2 = new Student();
p2.sayHi();//调Student的
Person p1 = new Student();
p1.sayHi();//调Student的


class Person{
  String name;
  int age;
  String address;
  void sayHi(){
     System.out.println(name+","+age+","+address)
  }
}
class Student extends Person{
   String className;
   void sayHi(){
     System.out.println(name+","+age+","+address+","+className)
  }
}
class Teacher extends Person{
   double salary;
   void sayHi(){
     System.out.println(name+","+age+","+address+","+salary)
  }
}
class Doctor extends Person{
   String level;
}